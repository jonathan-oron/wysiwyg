import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Paths
const themesDir = path.join(__dirname, 'themes');
const outputPath = path.join(__dirname, '../lib/theme-registry.ts');

// Read all theme files
const themeFiles = fs.readdirSync(themesDir)
  .filter(file => file.endsWith('.json'))
  .map(file => ({
    filename: file,
    data: JSON.parse(fs.readFileSync(path.join(themesDir, file), 'utf8'))
  }));

console.log(`ðŸ“¦ Found ${themeFiles.length} theme(s)`);

// Extract theme IDs and metadata
const themes = themeFiles.map(t => t.data.meta);

// Get primary color from semantic or palette
function getPrimaryColor(themeData) {
  if (themeData.color?.semantic?.primary?.$value) {
    const value = themeData.color.semantic.primary.$value;
    // If it's a reference like "{color.palette.brand.primary}", resolve it
    if (value.startsWith('{') && value.endsWith('}')) {
      const refPath = value.slice(1, -1).split('.');
      let current = themeData;
      for (const key of refPath) {
        current = current[key];
        if (!current) return '#000000';
      }
      return current.$value || '#000000';
    }
    return value;
  }
  return '#000000';
}

// Get background color from semantic or palette
function getBackgroundColor(themeData) {
  if (themeData.color?.semantic?.background?.$value) {
    const value = themeData.color.semantic.background.$value;
    if (value.startsWith('{') && value.endsWith('}')) {
      const refPath = value.slice(1, -1).split('.');
      let current = themeData;
      for (const key of refPath) {
        current = current[key];
        if (!current) return '#FFFFFF';
      }
      return current.$value || '#FFFFFF';
    }
    return value;
  }
  return '#FFFFFF';
}

// Get accent color from semantic or palette
function getAccentColor(themeData) {
  if (themeData.color?.semantic?.accent?.$value) {
    const value = themeData.color.semantic.accent.$value;
    if (value.startsWith('{') && value.endsWith('}')) {
      const refPath = value.slice(1, -1).split('.');
      let current = themeData;
      for (const key of refPath) {
        current = current[key];
        if (!current) return '#000000';
      }
      return current.$value || '#000000';
    }
    return value;
  }
  return '#000000';
}

// Build theme metadata objects
const themeMetadata = themeFiles.map(t => ({
  id: t.data.meta.id,
  name: t.data.meta.name,
  description: t.data.meta.description,
  category: t.data.meta.category,
  author: t.data.meta.author,
  version: t.data.meta.version,
  preview: {
    primary: getPrimaryColor(t.data),
    background: getBackgroundColor(t.data),
    accent: getAccentColor(t.data)
  }
}));

// Generate TypeScript content
const tsContent = `/**
 * Theme Registry - Auto-generated from theme files
 * DO NOT EDIT THIS FILE DIRECTLY
 * Run 'npm run generate-theme-types' to regenerate
 */

export type ThemeId =
  | ${themes.map(t => `'${t.id}'`).join('\n  | ')}
  | 'custom'

export type ThemeCategory = 'light' | 'dark'

export interface ThemeMetadata {
  id: ThemeId
  name: string
  description: string
  category: ThemeCategory
  author: string
  version: string
  preview: {
    primary: string
    background: string
    accent: string
  }
}

// Theme registry
export const themes: Record<Exclude<ThemeId, 'custom'>, ThemeMetadata> = {
${themeMetadata.map(t => `  '${t.id}': ${JSON.stringify(t, null, 2).replace(/\n/g, '\n  ')}`).join(',\n')}
}

// Utility functions
export function getTheme(id: Exclude<ThemeId, 'custom'>): ThemeMetadata {
  return themes[id]
}

export function getThemesByCategory(category: ThemeCategory): ThemeMetadata[] {
  return Object.values(themes).filter(theme => theme.category === category)
}

export function getDefaultTheme(): ThemeId {
  return 'terminal-dark'
}

export function isValidThemeId(id: string): id is ThemeId {
  return id === 'custom' || id in themes
}

export function getAllThemes(): ThemeMetadata[] {
  return Object.values(themes)
}
`;

// Ensure lib directory exists
const libDir = path.dirname(outputPath);
if (!fs.existsSync(libDir)) {
  fs.mkdirSync(libDir, { recursive: true });
}

// Write TypeScript file
fs.writeFileSync(outputPath, tsContent, 'utf8');

console.log('âœ… Theme types successfully generated!');
console.log(`ðŸ“„ Output: ${outputPath}`);
console.log(`ðŸŽ¨ Generated types for ${themes.length} theme(s):`);
for (const theme of themes) {
  console.log(`   - ${theme.name} (${theme.id})`);
}
