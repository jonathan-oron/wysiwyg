import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Read the tokens JSON file
const tokensPath = path.join(__dirname, 'tokens.json');
const outputPath = path.join(__dirname, '../styles/tokens.css');

const tokens = JSON.parse(fs.readFileSync(tokensPath, 'utf8'));

// Store all resolved tokens for reference resolution
const resolvedTokens = new Map();

/**
 * Convert a token path to a CSS variable name
 * e.g., "color.terminal.green" -> "--color-terminal-green"
 */
function tokenPathToCssVar(path) {
  return `--${path.replace(/\./g, '-')}`;
}

/**
 * Resolve token references like "{color.terminal.green}"
 */
function resolveReference(value, currentPath = '') {
  if (typeof value !== 'string') return value;

  const refMatch = value.match(/^\{(.+)\}$/);
  if (!refMatch) return value;

  const refPath = refMatch[1];
  if (resolvedTokens.has(refPath)) {
    return resolvedTokens.get(refPath);
  }

  // Return CSS var reference
  return `var(${tokenPathToCssVar(refPath)})`;
}

/**
 * Convert shadow object to CSS shadow value
 */
function shadowToCSS(shadow) {
  if (typeof shadow === 'string') return shadow;
  if (typeof shadow !== 'object' || shadow === null) return shadow;
  if (!shadow.offsetX && shadow.offsetX !== '0') return JSON.stringify(shadow);

  const spread = shadow.spread !== undefined ? ` ${shadow.spread}` : '';
  return `${shadow.offsetX} ${shadow.offsetY} ${shadow.blur}${spread} ${shadow.color}`;
}

/**
 * Convert array value to CSS value (for font families, cubic-bezier, etc.)
 */
function arrayToCSS(arr, type) {
  if (type === 'fontFamily') {
    return arr.map(font => font.includes(' ') ? `"${font}"` : font).join(', ');
  }
  if (type === 'cubicBezier') {
    return `cubic-bezier(${arr.join(', ')})`;
  }
  return arr.join(', ');
}

/**
 * Recursively process tokens and generate CSS variables
 */
function processTokens(obj, path = '', cssVars = [], parentType = null) {
  // Check if this object defines a type for its children
  const currentType = obj.$type || parentType;

  for (const [key, value] of Object.entries(obj)) {
    // Skip metadata keys
    if (key.startsWith('$')) continue;

    const currentPath = path ? `${path}.${key}` : key;

    // If this has a $value, it's a token
    if (value.$value !== undefined) {
      let cssValue = value.$value;
      const tokenType = value.$type || currentType;

      // Convert special types BEFORE resolving references
      if (tokenType === 'shadow' && typeof cssValue === 'object' && !Array.isArray(cssValue)) {
        cssValue = shadowToCSS(cssValue);
      } else if (Array.isArray(cssValue)) {
        cssValue = arrayToCSS(cssValue, tokenType);
      }

      // Resolve references (if cssValue is still a string with references)
      if (typeof cssValue === 'string') {
        cssValue = resolveReference(cssValue, currentPath);
      }

      // Store resolved value
      resolvedTokens.set(currentPath, cssValue);

      // Add to CSS vars
      const cssVarName = tokenPathToCssVar(currentPath);
      cssVars.push(`  ${cssVarName}: ${cssValue};`);
    } else {
      // Recurse into nested objects, passing down the current type
      processTokens(value, currentPath, cssVars, currentType);
    }
  }

  return cssVars;
}

// Generate CSS
const cssVars = processTokens(tokens);

const cssContent = `/**
 * Design Tokens - Auto-generated from tokens.json
 * DO NOT EDIT THIS FILE DIRECTLY
 * Run 'npm run build-tokens' to regenerate
 */

:root {
${cssVars.join('\n')}
}
`;

// Write CSS file
fs.writeFileSync(outputPath, cssContent, 'utf8');

console.log('âœ… Design tokens successfully converted to CSS variables!');
console.log(`ðŸ“„ Output: ${outputPath}`);
console.log(`ðŸŽ¨ Generated ${cssVars.length} CSS custom properties`);
