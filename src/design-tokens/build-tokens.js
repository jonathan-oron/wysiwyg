import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Paths
const baseTokensPath = path.join(__dirname, 'base-tokens.json');
const themesDir = path.join(__dirname, 'themes');
const outputPath = path.join(__dirname, '../styles/tokens.css');

// Read base tokens
const baseTokens = JSON.parse(fs.readFileSync(baseTokensPath, 'utf8'));

// Read all theme files
const themeFiles = fs.readdirSync(themesDir)
  .filter(file => file.endsWith('.json'))
  .map(file => ({
    filename: file,
    path: path.join(themesDir, file),
    data: JSON.parse(fs.readFileSync(path.join(themesDir, file), 'utf8'))
  }));

console.log(`üì¶ Found ${themeFiles.length} theme(s): ${themeFiles.map(t => t.data.meta.id).join(', ')}`);

/**
 * Convert a token path to a CSS variable name
 * e.g., "color.terminal.green" -> "--color-terminal-green"
 */
function tokenPathToCssVar(path) {
  return `--${path.replace(/\./g, '-')}`;
}

/**
 * Resolve token references like "{color.terminal.green}"
 */
function resolveReference(value, resolvedTokens) {
  if (typeof value !== 'string') return value;

  const refMatch = value.match(/^\{(.+)\}$/);
  if (!refMatch) return value;

  const refPath = refMatch[1];
  if (resolvedTokens.has(refPath)) {
    return resolvedTokens.get(refPath);
  }

  // Return CSS var reference
  return `var(${tokenPathToCssVar(refPath)})`;
}

/**
 * Convert shadow object to CSS shadow value
 */
function shadowToCSS(shadow) {
  if (typeof shadow === 'string') return shadow;
  if (typeof shadow !== 'object' || shadow === null) return shadow;
  if (!shadow.offsetX && shadow.offsetX !== '0') return JSON.stringify(shadow);

  const spread = shadow.spread !== undefined ? ` ${shadow.spread}` : '';
  return `${shadow.offsetX} ${shadow.offsetY} ${shadow.blur}${spread} ${shadow.color}`;
}

/**
 * Convert array value to CSS value (for font families, cubic-bezier, etc.)
 */
function arrayToCSS(arr, type) {
  if (type === 'fontFamily') {
    return arr.map(font => font.includes(' ') ? `"${font}"` : font).join(', ');
  }
  if (type === 'cubicBezier') {
    return `cubic-bezier(${arr.join(', ')})`;
  }
  return arr.join(', ');
}

/**
 * Recursively process tokens and generate CSS variables
 */
function processTokens(obj, path = '', cssVars = [], resolvedTokens = new Map(), parentType = null) {
  // Check if this object defines a type for its children
  const currentType = obj.$type || parentType;

  for (const [key, value] of Object.entries(obj)) {
    // Skip metadata keys
    if (key.startsWith('$') || key === 'meta') continue;

    const currentPath = path ? `${path}.${key}` : key;

    // If this has a $value, it's a token
    if (value.$value !== undefined) {
      let cssValue = value.$value;
      const tokenType = value.$type || currentType;

      // Convert special types BEFORE resolving references
      if (tokenType === 'shadow' && typeof cssValue === 'object' && !Array.isArray(cssValue)) {
        cssValue = shadowToCSS(cssValue);
      } else if (Array.isArray(cssValue)) {
        cssValue = arrayToCSS(cssValue, tokenType);
      }

      // Resolve references (if cssValue is still a string with references)
      if (typeof cssValue === 'string') {
        cssValue = resolveReference(cssValue, resolvedTokens);
      }

      // Store resolved value
      resolvedTokens.set(currentPath, cssValue);

      // Add to CSS vars
      const cssVarName = tokenPathToCssVar(currentPath);
      cssVars.push(`  ${cssVarName}: ${cssValue};`);
    } else {
      // Recurse into nested objects, passing down the current type
      processTokens(value, currentPath, cssVars, resolvedTokens, currentType);
    }
  }

  return { cssVars, resolvedTokens };
}

// Process base tokens
console.log('üî® Processing base tokens...');
const { cssVars: baseCssVars } = processTokens(baseTokens);

// Process each theme
const themeCssBlocks = [];
for (const theme of themeFiles) {
  console.log(`üé® Processing theme: ${theme.data.meta.name} (${theme.data.meta.id})`);

  // Validate required meta fields
  if (!theme.data.meta || !theme.data.meta.id) {
    console.error(`‚ùå Error: Theme ${theme.filename} is missing required meta.id field`);
    process.exit(1);
  }

  const { cssVars: themeCssVars } = processTokens(theme.data);

  themeCssBlocks.push({
    id: theme.data.meta.id,
    name: theme.data.meta.name,
    cssVars: themeCssVars
  });
}

// Generate final CSS content
let cssContent = `/**
 * Design Tokens - Auto-generated from design tokens
 * DO NOT EDIT THIS FILE DIRECTLY
 * Run 'npm run build-themes' to regenerate
 */

/* ===== BASE TOKENS (Universal) ===== */
:root {
${baseCssVars.join('\n')}
}

`;

// Add each theme
for (const themeBlock of themeCssBlocks) {
  cssContent += `/* ===== THEME: ${themeBlock.name} ===== */
[data-theme="${themeBlock.id}"] {
${themeBlock.cssVars.join('\n')}
}

`;
}

// Write CSS file
fs.writeFileSync(outputPath, cssContent, 'utf8');

console.log('‚úÖ Design tokens successfully converted to CSS variables!');
console.log(`üìÑ Output: ${outputPath}`);
console.log(`üé® Generated ${baseCssVars.length} base tokens`);
console.log(`üé® Generated ${themeFiles.length} theme(s)`);
for (const themeBlock of themeCssBlocks) {
  console.log(`   - ${themeBlock.name}: ${themeBlock.cssVars.length} tokens`);
}
